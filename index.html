<!doctype html>
<html>
<body>
  <button id="HBubble">BOLLA ORIZZONTALE</button>
  <button id="VBubble">BOLLA VERTICALE</button>
  <button id="save" disabled>Save file</button>

  <pre id="log"></pre>

<script>

const SERVICE_H_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";  //BOLLA ORIZZONTALE: ALIGN (1 riga)
const CHAR_H_UUID    = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const SERVICE_V_UUID = "25971dbc-e721-4b15-881b-d0eb84c894b1";  //BOLLA VERTICALE: ROLL/PITCH (2 righe)
const CHAR_V_UUID    = "bdc979f5-a3f9-4004-9a9f-544d8fcfaf4c";

const logEl = document.getElementById("log");
const log = (m) => logEl.textContent += m + "\n";

let ALIGN = null;
let ROLL  = null;
let PITCH = null;

//Pulsante 1: HBubble -> lettura ALIGN
document.getElementById("HBubble").onclick = async () => {
  try {
    log("\nSeleziona bolla orizzontale…");
    const txt = await readDeviceFiltered(SERVICE_H_UUID, CHAR_H_UUID);

    ALIGN = parseFloat(txt.trim());
    if (!Number.isFinite(ALIGN)) throw new Error("ALIGN non numerico");

    log("ALIGN = " + ALIGN);
    maybeEnableSave();

  } catch (e) {
    log("❌ " + e.message);
  }
};

//Pulsante 2: VBubble -> lettura ROLL/PITCH
document.getElementById("VBubble").onclick = async () => {
  try {
    log("\nSelect ROLL/PITCH device…");
    const txt = await readDeviceFiltered(SERVICE_V_UUID, CHAR_V_UUID);

    const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    if (lines.length < 2) throw new Error("Expected 2 lines");

    ROLL  = parseFloat(lines[0]);
    PITCH = parseFloat(lines[1]);

    log("ROLL  = " + ROLL);
    log("PITCH = " + PITCH);

    maybeEnableSave();

  } catch (e) {
    log("❌ " + e.message);
  }
};

//Search just 1 device with unique certain service
async function readDeviceFiltered(serviceUUID, charUUID) {
  let device = null;
  try {
    device = await navigator.bluetooth.requestDevice({
      filters: [{ services: [serviceUUID] }]
    });

    const server = await device.gatt.connect();
    const service = await server.getPrimaryService(serviceUUID);
    const ch = await service.getCharacteristic(charUUID);

    const dv = await ch.readValue();
    const txt = decodeText(dv);

    device.gatt.disconnect();
    return txt;

  } catch (err) {
    try { if (device?.gatt?.connected) device.gatt.disconnect(); } catch (_) {}
    throw err;
  }
}

//Decode data
function decodeText(dataView) {
  const bytes = new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength);
  return new TextDecoder().decode(bytes);
}

//Saving file
function maybeEnableSave() {
  if (ALIGN !== null || (ROLL !== null && PITCH !== null))
    document.getElementById("save").disabled = false;
}
document.getElementById("save").onclick = () => {
  let txt = "";
  if (ALIGN !== null) txt += `ALIGN: ${ALIGN}\n`;
  if (ROLL  !== null) txt += `ROLL: ${ROLL}\n`;
  if (PITCH !== null) txt += `PITCH: ${PITCH}\n`;

  const blob = new Blob([txt], { type: "text/plain" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "misure.txt";
  a.click();
  URL.revokeObjectURL(a.href);

  log("\nFile saved.");
};
</script>
</body>
</html>
